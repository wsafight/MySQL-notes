"use strict";(self.webpackChunkMYSQL_notes=self.webpackChunkMYSQL_notes||[]).push([[420],{1004:(e,a,n)=>{n.r(a),n.d(a,{data:()=>r});const r={key:"v-78ab6572",path:"/notes/paradigm.html",title:"设计范式",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"第一范式（1NF）",slug:"第一范式-1nf",children:[]},{level:3,title:"第二范式（2NF)",slug:"第二范式-2nf",children:[]},{level:3,title:"第三范式（3NF）",slug:"第三范式-3nf",children:[]},{level:3,title:"第四范式（4NF）",slug:"第四范式-4nf",children:[]},{level:3,title:"第五范式（5NF）",slug:"第五范式-5nf",children:[]}],filePathRelative:"notes/paradigm.md",git:{updatedTime:1627409616e3,contributors:[]}}},8518:(e,a,n)=>{n.r(a),n.d(a,{default:()=>h});const r=(0,n(6252).uE)('<h1 id="设计范式" tabindex="-1"><a class="header-anchor" href="#设计范式" aria-hidden="true">#</a> 设计范式</h1><h3 id="第一范式-1nf" tabindex="-1"><a class="header-anchor" href="#第一范式-1nf" aria-hidden="true">#</a> 第一范式（1NF）</h3><p>属性不可分</p><p>即表的列的具有原子性,不可再分解，即列的信息，不能分解, 只要数据库是关系型数据库(mysql/oracle/db2/informix/sysbase/sql server)，就自动的满足1NF。</p><h3 id="第二范式-2nf" tabindex="-1"><a class="header-anchor" href="#第二范式-2nf" aria-hidden="true">#</a> 第二范式（2NF)</h3><p>符合1NF，并且非主属性完全依赖于码。</p><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要我们设计一个主键来实现(这里的主键不包含业务逻辑)</p><h3 id="第三范式-3nf" tabindex="-1"><a class="header-anchor" href="#第三范式-3nf" aria-hidden="true">#</a> 第三范式（3NF）</h3><p>符合2NF，并且，消除传递依赖。 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主键字段。就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放(能尽量外键join就用外键join)。很多时候，我们为了满足第三范式往往会把一张表分成多张表</p><h3 id="第四范式-4nf" tabindex="-1"><a class="header-anchor" href="#第四范式-4nf" aria-hidden="true">#</a> 第四范式（4NF）</h3><p>要求把同一表内的多对多关系删除。</p><h3 id="第五范式-5nf" tabindex="-1"><a class="header-anchor" href="#第五范式-5nf" aria-hidden="true">#</a> 第五范式（5NF）</h3><p>从最终结构重新建立原始结构。</p>',13),h={render:function(e,a){return r}}}}]);